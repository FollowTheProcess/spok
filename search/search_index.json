{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#spok","title":"Spok","text":"<p>It's a build system Jim, but not as we know it! \ud83d\udd96\ud83c\udffb</p> <ul> <li>Free software: Apache Software License 2.0</li> </ul>"},{"location":"index.html#project-description","title":"Project Description","text":"<p><code>spok</code> is a lightweight build system and command runner inspired by things like make, just and others.</p> <p>On top of this, <code>spok</code> provides:</p> <ul> <li>A cleaner, more \"developer friendly\" syntax</li> <li>Fully cross compatible (tested on Windows, Linux and Mac)</li> <li>Ships with it's own shell interpreter so no dependency on <code>sh</code>, <code>bash</code>, or <code>zsh</code>!</li> <li>Incremental runs based on file hashing and sum checks (not timestamps like e.g. make), so nothing runs if nothing's changed!</li> <li>Incredibly fast execution! Expensive operations are cached, only does any work when it's absolutely necessary</li> <li>Auto loading of <code>.env</code> files</li> <li>Debug info with the <code>--verbose</code> flag</li> <li>An auto <code>spokfile</code> formatter</li> <li>More features TBC</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"<p>There are binaries for Mac, Linux and Windows in the GitHub releases section, just download the correct one for your OS and architecture and place it somewhere on <code>$PATH</code>.</p> <p>For Mac and Linux there is also a homebrew tap:</p> <pre><code>brew install FollowTheProcess/homebrew-tap/spok\n</code></pre>"},{"location":"index.html#quickstart","title":"Quickstart","text":"<p>To get started with spok, simply create a <code>spokfile</code> in your project and add a task:</p> <pre><code># Run the go tests\ntask test() {\n    go test ./...\n}\n</code></pre> <p>We also recommend you add the following to your <code>.gitignore</code>:</p> <pre><code>.spok/\n</code></pre> <p>Now on the command line you can run:</p> <pre><code>spok test\n</code></pre> <p>And your tests will be run!</p> <p>If you want spok to help you out by initialising a demo spokfile (and adding the <code>.spok</code> entry to <code>.gitignore</code>) you can run:</p> <pre><code>spok --init\n</code></pre>"},{"location":"index.html#the-spokfile","title":"The Spokfile","text":"<p>Spok is driven by a single file (usually placed in the root of your project) called <code>spokfile</code>.</p> <p>The syntax for a <code>spokfile</code> is inspired by a few different things and is intended to be expressive yet very simple:</p>"},{"location":"index.html#makefiles","title":"Makefiles","text":"<ul> <li>The general structure of a <code>spokfile</code> will be broadly familiar to those who have used make or just before.</li> <li>Tasks (make's targets or just's recipes) are independent declarations. A <code>spokfile</code> can have any number of tasks declared but each must have a unique name.</li> <li>Global variable definitions look similar.</li> </ul>"},{"location":"index.html#go","title":"Go","text":"<ul> <li>Spok borrows quite a bit of Go syntax!</li> <li>Global variables use the <code>:=</code> declaration operator.</li> <li>Tasks look kind of like Go functions.</li> <li>Tasks that output multiple things use Go's multiple return syntax.</li> <li>Task bodies are bounded with curly braces.</li> </ul>"},{"location":"index.html#python","title":"Python","text":"<ul> <li>Although in general whitespace is not significant in a <code>spokfile</code>, you'll notice there are no semicolons!</li> <li>Spok looks for line breaks in certain contexts to delimit things.</li> <li>Task outputs make use of the <code>-&gt;</code> operator similar to declaring function return types in Python.</li> </ul>"},{"location":"index.html#example","title":"Example","text":"<p>A <code>spokfile</code> looks like this...</p> <pre><code># Comments are preceded by a hash\n\n# You can store global variables like this (caps are optional)\n# these will also be exported as environment variables available for use\n# in any tasks commands\nGLOBAL_VARIABLE := \"hello\"\nBIN := \"./bin/main\"\n\n# You can store the output of a shell command as a variable\n# leading and trailing whitespace will always be trimmed off when doing this\nGIT_COMMIT := exec(\"git rev-parse HEAD\")\n\n# The core concept in spok is a task (think make target)\n# they are sort of based on go functions except arguments are dependencies\n# A dependency can be filepaths (including globs) or names of other tasks\n\n# Tasks have optional outputs (if they generate things)\n# This enables `spok --clean` to restore everything to it's original state\n\n# Generally, a task is structured like this...\n\n# A line comment above a task is it's docstring\n# task &lt;name&gt;(&lt;deps&gt;?...) -&gt; [(]&lt;outputs&gt;?...[)] {\n#     command(s) to run\n# }\n\n# Some simple examples below\n\n# Use a global variable like this\ntask hello() {\n    echo {{.GLOBAL_VARIABLE}}\n}\n\n# Run the go tests (depends on all go source files)\ntask test(\"**/*.go\") {\n    go test ./...\n}\n\n# Format the project source code (depends on all go source files)\n# if the go source files have not changed, this becomes a no op\ntask fmt(\"**/*.go\") {\n    go fmt ./...\n}\n\n# Compile the program (depends on fmt, fmt will run first)\n# also outputs a build binary\ntask build(fmt, \"**/*.go\") -&gt; \"./bin/main\" {\n    go build\n}\n\n# Can also use global variables as outputs\ntask build2(fmt, \"**/*.go\") -&gt; BIN {\n    go build\n}\n\n# Tasks can generate multiple things\ntask many(\"**/*.go\") -&gt; (\"output1.go\", \"output2.go\") {\n    go do many things\n}\n\n# Can also do glob outputs\n# e.g. tasks that populate entire directories like building documentation\ntask glob(\"docs/src/*.md\") -&gt; \"docs/build/*.html\" {\n    build docs\n}\n\n# Can register a default task (by default spok will list all tasks)\ntask default() {\n    echo \"default\"\n}\n\n# Can register a custom clean task\n# By default `spok --clean` will remove all declared outputs\n# if a task called \"clean\" is present in the spokfile\n# this task will be run instead when `--clean` is used\ntask clean() {\n    rm -rf somedir\n}\n</code></pre>"},{"location":"index.html#benchmarks","title":"Benchmarks","text":"<p>Although still in early development, I've benchmarked spok against some very large repos and it performs very well!</p> <p>For example on the golang/go repo itself with 8872 <code>.go</code> files (at the time of writing) and the following benchmark task:</p> <pre><code># Benchmark hashing all go files\ntask test(\"**/*.go\") {\n    echo \"I depend on all go files\"\n}\n</code></pre> <p></p> <p>Spok is able to hash all 8872 files in just 300ms!</p> <p></p> <p>Does that mean I can call spok \"Blazingly Fast!\"? \ud83e\udd14</p>"},{"location":"index.html#editor-support","title":"Editor Support","text":"<p>There is a VSCode Extension available that provides basic syntax highlighting for spokfiles. It's still in active development so more features TBC!</p>"},{"location":"cli.html","title":"CLI","text":"<p>Aside from what you can with the spokfile syntax itself, there's also a bunch of stuff you can do from the CLI.</p>"},{"location":"cli.html#usage","title":"Usage","text":"<p>Let's start by showing the help:</p> <pre><code>$ spok --help\n\nIt's a build system Jim, but not as we know it!\n\nSpok is a lightweight build system and command runner, inspired by things like\nmake, just etc.\n\nHowever, spok offers a number of additional features such as:\n\n- Cleaner, more developer-friendly syntax\n- Full cross compatibility\n- No dependency on any form of shell\n- Load .env files by default\n- Incremental runs based on file hashing and sum checks\n\nUSAGE:\n  spok [tasks]... [flags]\n\nFLAGS:\n  -c, --clean             Remove all build artifacts.\n      --fmt               Format the spokfile.\n  -f, --force             Bypass file hash checks and force running.\n  -h, --help              help for spok\n      --init              Initialise a new spokfile in $CWD.\n  -j, --json              Output task results as JSON.\n  -q, --quiet             Silence all CLI output.\n  -s, --show              Show all tasks defined in the spokfile.\n      --spokfile string   The path to the spokfile (defaults to '$CWD/spokfile').\n  -V, --vars              Show all defined variables in spokfile.\n  -v, --verbose           Show verbose logging output.\n      --version           version for spok\n</code></pre> <p>Some of this stuff we've already talked about, but let's look at some stuff we haven't touched on yet.</p>"},{"location":"cli.html#-fmt","title":"<code>--fmt</code>","text":"<p>The <code>--fmt</code> flag is used to format the spokfile. Spok comes equipped with an (albeit basic) formatter that parses the spokfile and then dumps it back in place with the desired formatting, simple really!</p> <p>Warning</p> <p>Because the spokfile has to be parsed before formatting, it's not possible to format a spokfile that contains syntax errors.</p>"},{"location":"cli.html#-force","title":"<code>--force</code>","text":"<p>If you've read the user guide you'll know that Spok calculates the state of the task dependency graph by hashing the contents of all the declared files in your task definition. This avoids unnecessary work by only running tasks who's dependencies have changed.</p> <p>However, sometimes you want to force a task to run regardless of whether it's dependencies have changed or not. This is where the <code>--force</code> flag comes in.</p> <pre><code>$ spok test\n- Task \"test\" skipped as none of it's dependencies have changed\n\n// Okay fine, let's force it to run\n$ spok test --force\n\nok   github.com/FollowTheProcess/spok/ast (cached)\nok   github.com/FollowTheProcess/spok/builtins (cached)\nok   github.com/FollowTheProcess/spok/cache (cached)\n?    github.com/FollowTheProcess/spok/cli/app [no test files]\n?    github.com/FollowTheProcess/spok/cli/cmd [no test files]\nok   github.com/FollowTheProcess/spok/cmd/spok (cached)\nok   github.com/FollowTheProcess/spok/file (cached)\nok   github.com/FollowTheProcess/spok/graph (cached)\nok   github.com/FollowTheProcess/spok/hash (cached)\n?    github.com/FollowTheProcess/spok/iostream [no test files]\nok   github.com/FollowTheProcess/spok/lexer (cached)\n?    github.com/FollowTheProcess/spok/logger [no test files]\nok   github.com/FollowTheProcess/spok/parser (cached)\nok   github.com/FollowTheProcess/spok/shell (cached)\nok   github.com/FollowTheProcess/spok/task (cached)\nok   github.com/FollowTheProcess/spok/token (cached)\n\n\u2705 Task \"test\" completed successfully\n</code></pre>"},{"location":"cli.html#-json","title":"<code>--json</code>","text":"<p>By default, spok outputs the results of the running tasks in their original format straight to the terminal. This is great for humans, but not so great for machines.</p> <p>If you want to programmatically access the results of a spok run, you can use the <code>--json</code> flag to output the results as JSON, which can then be queried by external programs e.g. jq.</p> <p>For example, let's run a sample task and pipe the output to <code>jq</code>:</p> <p>Here's the spokfile:</p> <pre><code># Do some things with JSON\ntask echo() {\n    echo \"I succeeded\"\n}\n</code></pre> <p>Running <code>spok echo --json</code> will get you:</p> <pre><code>$ spok echo --json | jq\n\n[\n  {\n    \"task\": \"echo\",\n    \"command_results\": [\n      {\n        \"cmd\": \"echo I succeeded\",\n        \"stdout\": \"I succeeded\\n\",\n        \"stderr\": \"\",\n        \"status\": 0\n      }\n    ],\n    \"skipped\": false\n  }\n]\n</code></pre> <p>Spok's output JSON is a list of objects, each object representing a task. Each task object contains the following fields:</p> <ul> <li><code>task</code>: The name of the task</li> <li><code>command_results</code>: A list of objects, each object representing a command run by the task. Each command object contains the following fields:</li> <li><code>cmd</code>: The command that was run</li> <li><code>stdout</code>: The stdout of the command</li> <li><code>stderr</code>: The stderr of the command</li> <li><code>status</code>: The exit status of the command</li> </ul> <p>You can imagine how this could be useful for things like CI/CD pipelines where tasks are more complicated and you may need to query or parse the results of a task or a whole run.</p>"},{"location":"cli.html#-quiet","title":"<code>--quiet</code>","text":"<p>The <code>--quiet</code> flag does exactly what it says on the tin, shuts Spok up!</p> <p>When using the <code>--quiet</code> flag, Spok will not show any of the task results or any other output at all, simply exit with a zero status code if the run was successful or a non-zero status code if it wasn't.</p> <p>I'd include an example here, but by definition it would be empty! \ud83e\udd13</p>"},{"location":"cli.html#-show","title":"<code>--show</code>","text":"<p>The <code>--show</code> flag simply displays all the tasks and their docstrings if present. By default, Spok will do this when it is invoked with no arguments, unless you have declared a task called <code>default</code>, see the user guide for more info on that!</p> <p>To show you what this looks like, consider a simple spokfile:</p> <pre><code># Run the unit tests\ntask test() {\n    go test ./...\n}\n\n# Format the source code\ntask fmt() {\n    go fmt ./...\n}\n\n# Run the linter\ntask lint() {\n    golangci-lint run --fix\n}\n</code></pre> <p>Running <code>spok</code> with no arguments, or <code>spok --show</code> will get you:</p> <pre><code>$ spok --show\nTasks defined in /Users/you/yourproject/spokfile:\nName    Description\nfmt     Run go fmt on all project files\nlint    Lint the project and auto-fix errors if possible\ntest    Run all project tests\n</code></pre> <p>Tip</p> <p><code>--show</code> comes in handy when you've reassigned the default task to do something else \ud83e\udde0</p>"},{"location":"cli.html#-spokfile","title":"<code>--spokfile</code>","text":"<p>The <code>--spokfile</code> flag is used to specify the path to the spokfile. By default, Spok will look for a spokfile in the current working directory.</p> <p>Note</p> <p>The path doesn't have to be absolute, if you use a relative path, Spok will assume you meant relative to the current working directory.</p>"},{"location":"cli.html#-vars","title":"<code>--vars</code>","text":"<p>The <code>--vars</code> flag tells Spok simply to print all the global variables in the spokfile and exit, this is useful for checking whether the outputs of spok's builtin functions are what you expect.</p> <p>For example:</p> <pre><code>TAG := exec(\"git describe --tags --abbrev=0\")\nCOMMIT := exec(\"git rev-parse HEAD\")\n</code></pre> <p>Will get you:</p> <pre><code>$ spok --vars\nVariables defined in /Users/you/yourproject/spokfile:\nName      Value\nTAG       0.3.0\nCOMMIT    3f2a1c2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f\n</code></pre>"},{"location":"cli.html#-verbose","title":"<code>--verbose</code>","text":"<p>If you're ever curious what's going on under the hood, you can use the <code>--verbose</code> flag to get a more detailed output of what Spok is doing during any other CLI operation:</p> <pre><code>$ spok test --verbose\n\n2022-11-27T10:10:26.441Z DEBUG Looking in /Users/tomfleet/Development/spok for spokfile\n2022-11-27T10:10:26.442Z DEBUG Found spokfile at /Users/tomfleet/Development/spok/spokfile\n2022-11-27T10:10:26.442Z DEBUG Looking for .env file\n2022-11-27T10:10:26.442Z DEBUG No .env file found\n2022-11-27T10:10:26.442Z DEBUG Parsing spokfile at /Users/tomfleet/Development/spok/spokfile\n2022-11-27T10:10:26.459Z DEBUG Running requested tasks: [test]\n2022-11-27T10:10:26.760Z DEBUG Building dependency graph for requested tasks: [test]\n2022-11-27T10:10:26.760Z DEBUG Calculating topological sort of dependency graph\n2022-11-27T10:10:26.761Z DEBUG Task test glob dependency pattern \"**/*.go\" expanded to 34 files\n2022-11-27T10:10:26.761Z DEBUG Task test depends on 34 files\n2022-11-27T10:10:26.765Z DEBUG Task test current checksum: 670d2ef1c36f6e1 cached checksum: 670d2ef1c36f6e1\n- Task \"test\" skipped as none of its dependencies have changed\n</code></pre>"},{"location":"contributing.html","title":"Contribution Guide","text":""},{"location":"contributing.html#contributing-to-spok","title":"Contributing to spok","text":"<p>I've tried to structure spok to make it nice and easy for people to contribute. Here's how to go about doing it! </p>"},{"location":"contributing.html#developing","title":"Developing","text":"<p>If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to spok: here's how you do it!</p>"},{"location":"contributing.html#step-1-fork-spok","title":"Step 1: Fork spok","text":"<p>The first thing to do is 'fork' spok. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of spok still works!</p> <p>To create a fork, go to the spok repo and click on the fork button!</p>"},{"location":"contributing.html#step-2-clone-your-fork","title":"Step 2: Clone your fork","text":"<p>Navigate to where you do your development work on your machine and open a terminal</p> <p>If you use HTTPS:</p> <pre><code>git clone https://github.com/&lt;your_github_username&gt;/spok.git\n</code></pre> <p>If you use SSH:</p> <pre><code>git clone git@github.com:&lt;your_github_username&gt;/spok.git\n</code></pre> <p>Or you can be really fancy and use the GH CLI</p> <pre><code>gh repo clone &lt;your_github_username&gt;/spok\n</code></pre> <p>HTTPS is probably the one most people use!</p> <p>Once you've cloned the project, cd into it...</p> <pre><code>cd spok\n</code></pre> <p>This will take you into the root directory of the project.</p> <p>Now add the original spok repo as an upstream in your forked project:</p> <pre><code>git remote add upstream https://github.com/FollowTheProcess/spok.git\n</code></pre> <p>This makes the original version of spok <code>upstream</code> but not <code>origin</code>. Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do:</p> <pre><code>git checkout main\ngit fetch upstream\ngit merge upstream/main\ngit push origin main\n</code></pre> <p>This will (in order):</p> <ul> <li>Checkout the main branch of your locally cloned fork</li> <li>Fetch any changes from the original project that have happened since you forked it</li> <li>Merge those changes in with what you have</li> <li>Push those changes up to your fork so your fork stays up to date with the original.</li> </ul> <p>Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower!</p>"},{"location":"contributing.html#step-3-make-your-change","title":"Step 3: Make your Change","text":"<p>Always checkout a new branch before changing anything</p> <pre><code>git switch --create &lt;name-of-your-bugfix-or-feature&gt;\n</code></pre> <p>Now you're ready to start working!</p> <p>Remember! spok aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future!</p> <p>spok uses just for automated testing, formatting and linting etc. So when you've made your changes, just run:</p> <pre><code>just check\n</code></pre> <p>And it will tell you if something's wrong!</p>"},{"location":"contributing.html#step-4-commit-your-changes","title":"Step 4: Commit your changes","text":"<p>Once you're happy with what you've done, add the files you've changed:</p> <pre><code>git add &lt;changed-file(s)&gt;\n\n# Might be easier to do\ngit add -A\n\n# But be wary of this and check what it's added is what you wanted..\ngit status\n</code></pre> <p>Commit your changes:</p> <pre><code>git commit\n\n# Now write a good commit message explaining what you've done and why.\n</code></pre> <p>While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible:</p> <pre><code>git pull --rebase upstream main\n</code></pre> <p>Now push your changes to your fork:</p> <pre><code>git push origin &lt;your-branch-name&gt;\n</code></pre>"},{"location":"contributing.html#step-5-create-a-pull-request","title":"Step 5: Create a Pull Request","text":"<p>Now go to the original spok repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source.</p> <p>That's it! Your code will be tested automatically by spok's CI suite and if everything passes and your PR is approved and merged then it will become part of spok!</p>"},{"location":"contributing.html#contributing-to-docs","title":"Contributing to Docs","text":"<p>Any improvements to the documentation are always appreciated! spok uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the <code>docs</code> folder in the project root.</p> <p>Spok uses nox to build and serve the documentation, nox is a python project and can be installed with pipx.</p> <pre><code># Builds the docs\nnox -s build\n\n# Builds and serves\nnox -s serve\n</code></pre> <p>If you use the <code>serve</code> option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! </p> <p>If you add pages to the docs, make sure they are placed in the nav tree in the <code>mkdocs.yml</code> file and you're good to go!</p>"},{"location":"quickstart.html","title":"Quickstart","text":"<p>Getting started with spok is easy! All you need to do is run:</p> <pre><code>$ spok --init\n\n\u2705 Done\n</code></pre> <p>This will create a spokfile in your current directory that looks like this:</p> <pre><code># This is a spokfile example\n\nVERSION := \"0.3.0\"\n\n# Run the unit tests\ntask test(\"**/*.go\") {\n    go test ./...\n}\n\n# Which version am I\ntask version() {\n    echo {{.VERSION}}\n}\n</code></pre> <p>And add the following to your <code>.gitignore</code>:</p> <pre><code># Ignore the spok cache directory\n.spok/\n</code></pre> <p>So now you're ready to go, if you run <code>spok</code> you'll see the following:</p> <pre><code>$ spok\nTasks defined in /Users/you/yourproject/spokfile:\nName        Description\ntest        Run the unit tests\nversion     Which version am I\n</code></pre> <p>If you run <code>spok version</code> you'll see:</p> <pre><code>$ spok version\n0.3.0\n</code></pre> <p>Next let's take a look at the spokfile syntax and how to use it.</p>"},{"location":"user_guide.html","title":"User Guide","text":""},{"location":"user_guide.html#syntax","title":"Syntax","text":"<p>When spok runs, it parses the syntax in your spokfile, extracts tasks, variables, and dependencies, and then runs the tasks you specify. In this section we'll take a look at the syntax and how to use it</p>"},{"location":"user_guide.html#global-variables","title":"Global Variables","text":"<p>Let's start simple, Spok lets you define variables in the global scope. These variables can be used in any task. For example:</p> <pre><code>VERSION := \"0.3.0\"\n\n# Show the version\ntask version() {\n    echo {{.VERSION}}\n}\n</code></pre> <p>Tip</p> <p>Global variables are also exported as environment variables to the tasks, so if your tasks invoke other scripts that depend on environment variables you can just declare them globally in spok.</p>"},{"location":"user_guide.html#builtin-functions","title":"Builtin Functions","text":"<p>Sometimes you need to do more than just run a test, or you need to do something that is not supported by the shell. Spok has a few builtin functions that you can use in your tasks. These functions are:</p> <ul> <li><code>join</code> - Joins a list of path parts with an OS specific path separator and returns the absolute path</li> <li><code>exec</code> - Executes a shell command and captures the output (stripped of leading/trailing whitespace) in the variable it's assigned to</li> </ul> <p>You use them like this:</p> <pre><code>DOCS_SRC := join(\".\", \"docs\", \"src\") # =&gt; \"/Users/you/project/docs/src\"\n\nGIT_COMMIT := exec(\"git rev-parse HEAD\") # =&gt; \"a1b2c3d4e5f6\"\n</code></pre> <p>Note</p> <p>More builtins TBC, spok is still in its early stages \ud83d\ude80</p>"},{"location":"user_guide.html#tasks","title":"Tasks","text":"<p>Tasks are the main point of Spok and are most likely where you'll spend most of your time. Tasks are preceded with the <code>task</code> keyword followed by the task definition.</p> <p>For example, a simple task that runs unit tests might look like:</p> <pre><code>task test() {\n    go test ./...\n}\n</code></pre> <p>Warning</p> <p>Just like functions in most programming languages, tasks must have opening and closing parentheses, omitting them is grounds for a syntax error.</p> <p>Now that you have a task defined, you can run it with <code>spok test</code> and your tests will run, how cool is that! \ud83c\udf89</p>"},{"location":"user_guide.html#task-documentation","title":"Task Documentation","text":"<p>If you want to document your tasks, you can do so by adding a comment above the task definition. For example:</p> <pre><code># Run all project unit tests\ntask test() {\n    go test ./...\n}\n</code></pre> <p>Spok will parse this as the task's docstring and it will be output when the tasks are listed, either by the default action or the <code>--show</code> flag. But we'll get to that later in the CLI section \ud83d\udc4d</p>"},{"location":"user_guide.html#tasks-that-depend-on-files","title":"Tasks that Depend on Files","text":"<p>This is fine, and might be enough for you if your test suite is fast and/or the language tooling you're using caches results (like Go!). But what if you have a large test suite and only want to re-run the tests if the source code has changed? Or what if you have a task that depends on another?</p> <p>Luckily, Spok supports both of these types of dependencies!</p> <p>Let's say you're working in a very large python project and the tests take a while to run. You don't want to run the tests if the source code hasn't changed since you last ran them. You can do this by adding a dependency to the <code>test</code> task:</p> <pre><code>task test(\"**/*.py\") {\n    python -m pytest\n}\n</code></pre> <p>By including the <code>\"**/*.py\"</code>, Spok will now know that the <code>test</code> task depends on all python files in the project, and that (after the initial run) it should only be re-run if any of those files have changed.</p> <p>So now if you run <code>spok test</code>, your tests will run as before. But try running it again! Spok will notice that none of the python files have changed and you will see:</p> <pre><code>$ spok test\n- Task \"test\" skipped as none of its dependencies have changed\n</code></pre> <p>You can do this with as many files or glob patterns as you want, if any of them have changed, the task will be re-run, e.g. this is completely allowed:</p> <pre><code>task lots(\"**/*.go\", \"**/*.py\", \"some/specific/file.txt\") {\n    ...\n}\n</code></pre> <p>Info</p> <p>When you declare file dependencies like this, behind the scenes Spok will expand the glob patterns to their concrete, absolute filepaths, open and read the contents of each one, and then generate a SHA256 hash of the contents, summing it all up into a final digest and caching this digest against the name of the task.</p> <p>When you run the task again, Spok will do the same procedure, and compare the newly calculated digest against the cached one to determine if the task should be re run. This type of content checking is more accurate than e.g. make which looks at file modification timestamps.</p>"},{"location":"user_guide.html#a-note-on-performance","title":"A Note on Performance","text":"<p>\"But if you open and read the contents of every single file every time you run the task, isn't this really slow?\"</p> <p>In a word... no! Spok is designed to be fast:</p> <ul> <li>The expansion of glob patterns happens once, when the spokfile is parsed, and the results are cached in memory for reuse</li> <li>The opening, reading and hashing of file contents happens concurrently across all your cores</li> <li>It's written in Go so it's naturally pretty fast anyway!</li> </ul> <p>All this means that, even on very large projects, Spok can perform this check in a few hundred milliseconds \ud83d\ude80</p> <p>For example on the golang/go repo itself with 8872 <code>.go</code> files (at the time of writing) and the following benchmark task:</p> <pre><code># Benchmark hashing all go files\ntask test(\"**/*.go\") {\n    echo \"I depend on all go files\"\n}\n</code></pre> <p></p> <p></p> <p>Spok is able to detect that nothing has changed in any of the 8872 files in just 300ms on my laptop! Don't forget, this also includes the time it takes to:</p> <ul> <li>Launch the program itself</li> <li>Read and parse the spokfile</li> <li>Expand the glob pattern <code>\"**/*.go\"</code> and collect the results</li> </ul> <p>So hopefully it's plenty fast enough!</p>"},{"location":"user_guide.html#tasks-that-depend-on-other-tasks","title":"Tasks that Depend on Other Tasks","text":"<p>Not only can you depend on files, you can also depend on other tasks, or a mix of both! If you put the name of another task in the task arguments, Spok will recognise this as a task dependency and will ensure that the declared task will always run before the one you want.</p> <p>For example, let's say you want a Spok task to compile your project, but before that you have to run some sort of code generation, or you want to run the linter or formatter first. You can do this by declaring a dependency in your build task on whatever you want to run before it:</p> <pre><code># Run the formatter\ntask fmt() {\n    go fmt ./...\n}\n\n# Run the linter\ntask lint(fmt) {\n    golangci-lint run\n}\n\n# Compile the project\ntask build(lint) {\n    go build ./...\n}\n</code></pre> <p>In this example, the <code>build</code> task depends on the <code>lint</code> task, which in-turn depends on the <code>fmt</code> task. So when you run <code>spok build</code>, Spok will construct the dependency graph of the requested tasks, and then run them in the correct order, so you should see something like:</p> <pre><code>$ spok build\n\n\u2705 Task \"fmt\" completed successfully\n\u2705 Task \"lint\" completed successfully\n\u2705 Task \"build\" completed successfully\n</code></pre> <p>You can also mix and match tasks depending on files and each other, as in the following example:</p> <pre><code># Generate the API schema from swagger\ntask generate(\"api/swagger.yaml\") {\n    swagger generate spec -o api/schema.json\n}\n\n# Compile the project\ntask build(generate, \"**/*.go\") {\n    go build ./...\n}\n</code></pre> <p>Here we want to generate an API schema from a swagger file, but only if the swagger file has changed. We also want to compile the project which may include or embed this swagger schema, so <code>generate</code> will always run first, and then <code>build</code> will run, but only if any of the go files have changed since the last run.</p> <p>Hopefully you can see how powerful this is! Using a very simple and expressive syntax, you can build up complex dependency graphs of tasks that will only run when they need to, so no time is wasted doing unnecessary work.</p> <p>Note</p> <p>At the moment, spok will not recurse down the dependency graph and so will not look at dependencies of dependencies. For example if you had the following spokfile:</p> <pre><code># Run the linter\ntask lint(\"**/*.go\") {\n    golangci-lint run\n}\n\n# Run the tests\ntask test(lint) {\n    go test ./...\n}\n</code></pre> <p>Task <code>test</code> would always run after <code>lint</code>, but it would run even if no go files had changed. To declare that <code>test</code> should also only run if any of the go files have changed, you would need to add the dependency to <code>test</code> as well:</p> <pre><code># Run the tests\ntask test(lint, \"**/*.go\") {\n    go test ./...\n}\n</code></pre>"},{"location":"user_guide.html#task-outputs","title":"Task Outputs","text":"<p>Some tasks generate external artifacts, such as compiled binaries, or generated code. In Spok, you can explicitly declare this by using the output operator <code>-&gt;</code>. For example, here's a task that compiles a Go binary and saves it under the <code>bin</code> directory:</p> <pre><code># Build the project\ntask build(\"**/*.go\") -&gt; \"bin/myproject\" {\n    go build -o bin/myproject ./...\n}\n</code></pre> <p>Declaring an output like this is optional, but it has a pretty cool benefit!</p> <pre><code>$ spok --clean\n\nRemoved /Users/you/myproject/bin/myproject\n</code></pre> <p>Yep, Spok can automatically clean up after you! \ud83c\udf89</p> <p>This is useful if you generate a lot of stuff and want to easily clean up after yourself e.g. if your tasks generate profiles, coverage reports, flamegraphs or other artifacts that you don't want to commit to your repo.</p> <p>You can also declare multiple outputs by separating them with commas inside parentheses, like so:</p> <pre><code># Output lots of stuff\ntask build(\"**/*.go\") -&gt; (\"bin/myproject\", \"bin/myproject2\") {\n    go build -o bin/myproject ./...\n    go build -o bin/myproject2 ./...\n}\n</code></pre> <p>Or even glob patterns of outputs! For example if your task is to convert markdown to html docs pages, you could do something like:</p> <pre><code># Build the docs html from source\ntask docs(\"docs/src/*.md\") -&gt; \"docs/build/*.html\" {\n    mkdocs build\n}\n</code></pre> <p>Just like with file dependencies, these globs will be expanded to their concrete filepaths and each one would be deleted by <code>spok --clean</code></p>"},{"location":"user_guide.html#default-tasks","title":"Default Tasks","text":"<p>We saw earlier that if you run <code>spok</code> without any arguments, it will show the list of all tasks in your spokfile. But what if you wanted to do something else instead? Well... you can!</p> <p>All you need to do is declare a task called <code>default</code> and then when you run <code>spok</code> without any arguments, it will run that task instead:</p> <pre><code># Do this by default\ntask default() {\n    echo \"Hello from the default task\"\n}\n</code></pre> <pre><code>$ spok\nHello from the default task\n</code></pre>"},{"location":"user_guide.html#custom-clean-operation","title":"Custom Clean Operation","text":"<p>Spok automatically keeps track of task outputs and will delete them when you run <code>spok --clean</code>. But like declaring default tasks, you can also declare a custom clean operation by writing a task called <code>clean</code>:</p> <pre><code># Do custom cleany things\ntask clean() {\n    echo \"Cleaning up...\"\n}\n</code></pre> <pre><code>$ spok --clean\nCleaning up...\n</code></pre>"},{"location":"user_guide.html#dotenv-support","title":"Dotenv Support","text":"<p>If Spok finds a file called <code>.env</code> in the same directory as your spokfile, it will automatically load it and make the variables available to all it's tasks.</p> <p>For example, if you had a <code>.env</code> file like this:</p> <pre><code>VALUE=\"hello from .env\"\n</code></pre> <p>And a spokfile like this:</p> <pre><code># Use a variable from .env\ntask dotenv() {\n    echo $VALUE\n}\n</code></pre> <p>When you run <code>spok dotenv</code>, you'll get:</p> <pre><code>$ spok dotenv\nhello from .env\n</code></pre> <p>That's really it! Let's move on and talk about what you can do with the CLI</p>"}]}
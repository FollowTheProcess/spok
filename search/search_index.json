{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Spok \u00b6 It's a build system Jim, but not as we know it! \ud83d\udd96\ud83c\udffb Free software: Apache Software License 2.0 Project Description \u00b6 Spok is still in development and is not ready for use yet! spok is a lightweight build system and command runner inspired by things like make , just and others. On top of this, spok provides: A cleaner, more \"developer friendly\" syntax Fully cross compatible (tested on Windows, Linux and Mac) Ships with it's own shell interpreter so no dependency on sh , bash , or zsh ! Incremental runs based on file hashing and sum checks (not timestamps like e.g. make ), so nothing runs if nothing's changed! Incredibly fast execution! Expensive operations are cached, only does any work when it's absolutely necessary Auto loading of .env files Debug info with the --verbose flag An auto spokfile formatter More features TBC Installation \u00b6 There are binaries for Mac, Linux and Windows in the GitHub releases section, just download the correct one for your OS and architecture and place it somewhere on $PATH . For Mac and Linux there is also a homebrew tap: brew install FollowTheProcess/homebrew-tap/spok Quickstart \u00b6 To get started with spok, simply create a spokfile in your project and add a task: # Run the go tests task test () { go test ./... } We also recommend you add the following to your .gitignore : .spok/ Now on the command line you can run: spok test And your tests will be run! If you want spok to help you out by initialising a demo spokfile (and adding the .spok entry to .gitignore ) you can run: spok --init The Spokfile \u00b6 Spok is driven by a single file (usually placed in the root of your project) called spokfile . The syntax for a spokfile is inspired by a few different things and is intended to be expressive yet very simple: Makefiles \u00b6 The general structure of a spokfile will be broadly familiar to those who have used make or just before. Tasks (make's targets or just's recipes) are independent declarations. A spokfile can have any number of tasks declared but each must have a unique name. Global variable definitions look similar. Go \u00b6 Spok borrows quite a bit of Go syntax! Global variables use the := declaration operator. Tasks look kind of like Go functions. Tasks that output multiple things use Go's multiple return syntax. Task bodies are bounded with curly braces. Python \u00b6 Although in general whitespace is not significant in a spokfile , you'll notice there are no semicolons! Spok looks for line breaks in certain contexts to delimit things. Task outputs make use of the -> operator similar to declaring function return types in Python. Example \u00b6 A spokfile looks like this... # Comments are preceded by a hash # You can store global variables like this (caps are optional) # these will also be exported as environment variables available for use # in any tasks commands GLOBAL_VARIABLE := \"hello\" BIN := \"./bin/main\" # You can store the output of a shell command as a variable # leading and trailing whitespace will always be trimmed off when doing this GIT_COMMIT := exec ( \"git rev-parse HEAD\" ) # The core concept in spok is a task (think make target) # they are sort of based on go functions except arguments are dependencies # A dependency can be filepaths (including globs) or names of other tasks # Tasks have optional outputs (if they generate things) # This enables `spok --clean` to restore everything to it's original state # Generally, a task is structured like this... # A line comment above a task is it's docstring # task <name>(<deps>?...) -> [(]<outputs>?...[)] { # command(s) to run # } # Some simple examples below # Use a global variable like this task hello () { echo {{ . GLOBAL_VARIABLE }} } # Run the go tests (depends on all go source files) task test ( \"**/*.go\" ) { go test ./... } # Format the project source code (depends on all go source files) # if the go source files have not changed, this becomes a no op task fmt ( \"**/*.go\" ) { go fmt ./... } # Compile the program (depends on fmt, fmt will run first) # also outputs a build binary task build ( fmt , \"**/*.go\" ) -> \"./bin/main\" { go build } # Can also use global variables as outputs task build2 ( fmt , \"**/*.go\" ) -> BIN { go build } # Tasks can generate multiple things task many ( \"**/*.go\" ) -> ( \"output1.go\" , \"output2.go\" ) { go do many things } # Can also do glob outputs # e.g. tasks that populate entire directories like building documentation task glob ( \"docs/src/*.md\" ) -> \"docs/build/*.html\" { build docs } # Can register a default task (by default spok will list all tasks) task default () { echo \"default\" } # Can register a custom clean task # By default `spok --clean` will remove all declared outputs # if a task called \"clean\" is present in the spokfile # this task will be run instead when `--clean` is used task clean () { rm - rf somedir } Benchmarks \u00b6 Although still in early development, I've benchmarked spok against some very large repos and it performs very well! For example on the golang/go repo itself with 8872 .go files (at the time of writing) and the following benchmark task: # Benchmark hashing all go files task test ( \"**/*.go\" ) { echo \"I depend on all go files\" } Spok is able to hash all 8872 files in just 300ms! Does that mean I can call spok \"Blazingly Fast!\" ? \ud83e\udd14 Editor Support \u00b6 There is a VSCode Extension available that provides basic syntax highlighting for spokfiles. It's still in active development so more features TBC!","title":"Home"},{"location":"index.html#spok","text":"It's a build system Jim, but not as we know it! \ud83d\udd96\ud83c\udffb Free software: Apache Software License 2.0","title":"Spok"},{"location":"index.html#project-description","text":"Spok is still in development and is not ready for use yet! spok is a lightweight build system and command runner inspired by things like make , just and others. On top of this, spok provides: A cleaner, more \"developer friendly\" syntax Fully cross compatible (tested on Windows, Linux and Mac) Ships with it's own shell interpreter so no dependency on sh , bash , or zsh ! Incremental runs based on file hashing and sum checks (not timestamps like e.g. make ), so nothing runs if nothing's changed! Incredibly fast execution! Expensive operations are cached, only does any work when it's absolutely necessary Auto loading of .env files Debug info with the --verbose flag An auto spokfile formatter More features TBC","title":"Project Description"},{"location":"index.html#installation","text":"There are binaries for Mac, Linux and Windows in the GitHub releases section, just download the correct one for your OS and architecture and place it somewhere on $PATH . For Mac and Linux there is also a homebrew tap: brew install FollowTheProcess/homebrew-tap/spok","title":"Installation"},{"location":"index.html#quickstart","text":"To get started with spok, simply create a spokfile in your project and add a task: # Run the go tests task test () { go test ./... } We also recommend you add the following to your .gitignore : .spok/ Now on the command line you can run: spok test And your tests will be run! If you want spok to help you out by initialising a demo spokfile (and adding the .spok entry to .gitignore ) you can run: spok --init","title":"Quickstart"},{"location":"index.html#the-spokfile","text":"Spok is driven by a single file (usually placed in the root of your project) called spokfile . The syntax for a spokfile is inspired by a few different things and is intended to be expressive yet very simple:","title":"The Spokfile"},{"location":"index.html#makefiles","text":"The general structure of a spokfile will be broadly familiar to those who have used make or just before. Tasks (make's targets or just's recipes) are independent declarations. A spokfile can have any number of tasks declared but each must have a unique name. Global variable definitions look similar.","title":"Makefiles"},{"location":"index.html#go","text":"Spok borrows quite a bit of Go syntax! Global variables use the := declaration operator. Tasks look kind of like Go functions. Tasks that output multiple things use Go's multiple return syntax. Task bodies are bounded with curly braces.","title":"Go"},{"location":"index.html#python","text":"Although in general whitespace is not significant in a spokfile , you'll notice there are no semicolons! Spok looks for line breaks in certain contexts to delimit things. Task outputs make use of the -> operator similar to declaring function return types in Python.","title":"Python"},{"location":"index.html#example","text":"A spokfile looks like this... # Comments are preceded by a hash # You can store global variables like this (caps are optional) # these will also be exported as environment variables available for use # in any tasks commands GLOBAL_VARIABLE := \"hello\" BIN := \"./bin/main\" # You can store the output of a shell command as a variable # leading and trailing whitespace will always be trimmed off when doing this GIT_COMMIT := exec ( \"git rev-parse HEAD\" ) # The core concept in spok is a task (think make target) # they are sort of based on go functions except arguments are dependencies # A dependency can be filepaths (including globs) or names of other tasks # Tasks have optional outputs (if they generate things) # This enables `spok --clean` to restore everything to it's original state # Generally, a task is structured like this... # A line comment above a task is it's docstring # task <name>(<deps>?...) -> [(]<outputs>?...[)] { # command(s) to run # } # Some simple examples below # Use a global variable like this task hello () { echo {{ . GLOBAL_VARIABLE }} } # Run the go tests (depends on all go source files) task test ( \"**/*.go\" ) { go test ./... } # Format the project source code (depends on all go source files) # if the go source files have not changed, this becomes a no op task fmt ( \"**/*.go\" ) { go fmt ./... } # Compile the program (depends on fmt, fmt will run first) # also outputs a build binary task build ( fmt , \"**/*.go\" ) -> \"./bin/main\" { go build } # Can also use global variables as outputs task build2 ( fmt , \"**/*.go\" ) -> BIN { go build } # Tasks can generate multiple things task many ( \"**/*.go\" ) -> ( \"output1.go\" , \"output2.go\" ) { go do many things } # Can also do glob outputs # e.g. tasks that populate entire directories like building documentation task glob ( \"docs/src/*.md\" ) -> \"docs/build/*.html\" { build docs } # Can register a default task (by default spok will list all tasks) task default () { echo \"default\" } # Can register a custom clean task # By default `spok --clean` will remove all declared outputs # if a task called \"clean\" is present in the spokfile # this task will be run instead when `--clean` is used task clean () { rm - rf somedir }","title":"Example"},{"location":"index.html#benchmarks","text":"Although still in early development, I've benchmarked spok against some very large repos and it performs very well! For example on the golang/go repo itself with 8872 .go files (at the time of writing) and the following benchmark task: # Benchmark hashing all go files task test ( \"**/*.go\" ) { echo \"I depend on all go files\" } Spok is able to hash all 8872 files in just 300ms! Does that mean I can call spok \"Blazingly Fast!\" ? \ud83e\udd14","title":"Benchmarks"},{"location":"index.html#editor-support","text":"There is a VSCode Extension available that provides basic syntax highlighting for spokfiles. It's still in active development so more features TBC!","title":"Editor Support"},{"location":"cli.html","text":"CLI \u00b6 Aside from what you can with the spokfile syntax itself, there's also a bunch of stuff you can do from the CLI. Usage \u00b6 Let's start by showing the help: $ spok --help It's a build system Jim, but not as we know it! Spok is a lightweight build system and command runner, inspired by things like make, just etc. However, spok offers a number of additional features such as: - Cleaner, more developer-friendly syntax - Full cross compatibility - No dependency on any form of shell - Load .env files by default - Incremental runs based on file hashing and sum checks USAGE: spok [tasks]... [flags] FLAGS: -c, --clean Remove all build artifacts. --fmt Format the spokfile. -f, --force Bypass file hash checks and force running. -h, --help help for spok --init Initialise a new spokfile in $CWD. -j, --json Output task results as JSON. -q, --quiet Silence all CLI output. -s, --show Show all tasks defined in the spokfile. --spokfile string The path to the spokfile (defaults to '$CWD/spokfile'). -V, --vars Show all defined variables in spokfile. -v, --verbose Show verbose logging output. --version version for spok Some of this stuff we've already talked about, but let's look at some stuff we haven't touched on yet. --fmt \u00b6 The --fmt flag is used to format the spokfile. Spok comes equipped with an (albeit basic) formatter that parses the spokfile and then dumps it back in place with the desired formatting, simple really! Warning Because the spokfile has to be parsed before formatting, it's not possible to format a spokfile that contains syntax errors. --force \u00b6 If you've read the user guide you'll know that Spok calculates the state of the task dependency graph by hashing the contents of all the declared files in your task definition. This avoids unnecessary work by only running tasks who's dependencies have changed. However, sometimes you want to force a task to run regardless of whether it's dependencies have changed or not. This is where the --force flag comes in. $ spok test - Task \"test\" skipped as none of it's dependencies have changed // Okay fine, let's force it to run $ spok test --force ok github.com/FollowTheProcess/spok/ast (cached) ok github.com/FollowTheProcess/spok/builtins (cached) ok github.com/FollowTheProcess/spok/cache (cached) ? github.com/FollowTheProcess/spok/cli/app [no test files] ? github.com/FollowTheProcess/spok/cli/cmd [no test files] ok github.com/FollowTheProcess/spok/cmd/spok (cached) ok github.com/FollowTheProcess/spok/file (cached) ok github.com/FollowTheProcess/spok/graph (cached) ok github.com/FollowTheProcess/spok/hash (cached) ? github.com/FollowTheProcess/spok/iostream [no test files] ok github.com/FollowTheProcess/spok/lexer (cached) ? github.com/FollowTheProcess/spok/logger [no test files] ok github.com/FollowTheProcess/spok/parser (cached) ok github.com/FollowTheProcess/spok/shell (cached) ok github.com/FollowTheProcess/spok/task (cached) ok github.com/FollowTheProcess/spok/token (cached) \u2705 Task \"test\" completed successfully --json \u00b6 By default, spok outputs the results of the running tasks in their original format straight to the terminal. This is great for humans, but not so great for machines. If you want to programmatically access the results of a spok run, you can use the --json flag to output the results as JSON, which can then be queried by external programs e.g. jq . For example, let's run a sample task and pipe the output to jq : Here's the spokfile: # Do some things with JSON task echo () { echo \"I succeeded\" } Running spok echo --json will get you: $ spok echo --json | jq [ { \"task\": \"echo\", \"command_results\": [ { \"cmd\": \"echo I succeeded\", \"stdout\": \"I succeeded\\n\", \"stderr\": \"\", \"status\": 0 } ], \"skipped\": false } ] Spok's output JSON is a list of objects, each object representing a task. Each task object contains the following fields: task : The name of the task command_results : A list of objects, each object representing a command run by the task. Each command object contains the following fields: cmd : The command that was run stdout : The stdout of the command stderr : The stderr of the command status : The exit status of the command You can imagine how this could be useful for things like CI/CD pipelines where tasks are more complicated and you may need to query or parse the results of a task or a whole run. --quiet \u00b6 The --quiet flag does exactly what it says on the tin, shuts Spok up! When using the --quiet flag, Spok will not show any of the task results or any other output at all, simply exit with a zero status code if the run was successful or a non-zero status code if it wasn't. I'd include an example here, but by definition it would be empty! \ud83e\udd13 --show \u00b6 The --show flag simply displays all the tasks and their docstrings if present. By default, Spok will do this when it is invoked with no arguments, unless you have declared a task called default , see the user guide for more info on that! To show you what this looks like, consider a simple spokfile: # Run the unit tests task test () { go test ./... } # Format the source code task fmt () { go fmt ./... } # Run the linter task lint () { golangci - lint run -- fix } Running spok with no arguments, or spok --show will get you: $ spok --show Tasks defined in /Users/you/yourproject/spokfile: Name Description fmt Run go fmt on all project files lint Lint the project and auto-fix errors if possible test Run all project tests Tip --show comes in handy when you've reassigned the default task to do something else \ud83e\udde0 --spokfile \u00b6 The --spokfile flag is used to specify the path to the spokfile. By default, Spok will look for a spokfile in the current working directory. Note The path doesn't have to be absolute, if you use a relative path, Spok will assume you meant relative to the current working directory. --vars \u00b6 The --vars flag tells Spok simply to print all the global variables in the spokfile and exit, this is useful for checking whether the outputs of spok's builtin functions are what you expect. For example: TAG := exec ( \"git describe --tags --abbrev=0\" ) COMMIT := exec ( \"git rev-parse HEAD\" ) Will get you: $ spok --vars Variables defined in /Users/you/yourproject/spokfile: Name Value TAG 0.3.0 COMMIT 3f2a1c2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f --verbose \u00b6 If you're ever curious what's going on under the hood, you can use the --verbose flag to get a more detailed output of what Spok is doing during any other CLI operation: $ spok test --verbose 2022-11-27T10:10:26.441Z DEBUG Looking in /Users/tomfleet/Development/spok for spokfile 2022-11-27T10:10:26.442Z DEBUG Found spokfile at /Users/tomfleet/Development/spok/spokfile 2022-11-27T10:10:26.442Z DEBUG Looking for .env file 2022-11-27T10:10:26.442Z DEBUG No .env file found 2022-11-27T10:10:26.442Z DEBUG Parsing spokfile at /Users/tomfleet/Development/spok/spokfile 2022-11-27T10:10:26.459Z DEBUG Running requested tasks: [test] 2022-11-27T10:10:26.760Z DEBUG Building dependency graph for requested tasks: [test] 2022-11-27T10:10:26.760Z DEBUG Calculating topological sort of dependency graph 2022-11-27T10:10:26.761Z DEBUG Task test glob dependency pattern \"**/*.go\" expanded to 34 files 2022-11-27T10:10:26.761Z DEBUG Task test depends on 34 files 2022-11-27T10:10:26.765Z DEBUG Task test current checksum: 670d2ef1c36f6e1 cached checksum: 670d2ef1c36f6e1 - Task \"test\" skipped as none of its dependencies have changed","title":"CLI"},{"location":"cli.html#cli","text":"Aside from what you can with the spokfile syntax itself, there's also a bunch of stuff you can do from the CLI.","title":"CLI"},{"location":"cli.html#usage","text":"Let's start by showing the help: $ spok --help It's a build system Jim, but not as we know it! Spok is a lightweight build system and command runner, inspired by things like make, just etc. However, spok offers a number of additional features such as: - Cleaner, more developer-friendly syntax - Full cross compatibility - No dependency on any form of shell - Load .env files by default - Incremental runs based on file hashing and sum checks USAGE: spok [tasks]... [flags] FLAGS: -c, --clean Remove all build artifacts. --fmt Format the spokfile. -f, --force Bypass file hash checks and force running. -h, --help help for spok --init Initialise a new spokfile in $CWD. -j, --json Output task results as JSON. -q, --quiet Silence all CLI output. -s, --show Show all tasks defined in the spokfile. --spokfile string The path to the spokfile (defaults to '$CWD/spokfile'). -V, --vars Show all defined variables in spokfile. -v, --verbose Show verbose logging output. --version version for spok Some of this stuff we've already talked about, but let's look at some stuff we haven't touched on yet.","title":"Usage"},{"location":"cli.html#-fmt","text":"The --fmt flag is used to format the spokfile. Spok comes equipped with an (albeit basic) formatter that parses the spokfile and then dumps it back in place with the desired formatting, simple really! Warning Because the spokfile has to be parsed before formatting, it's not possible to format a spokfile that contains syntax errors.","title":"--fmt"},{"location":"cli.html#-force","text":"If you've read the user guide you'll know that Spok calculates the state of the task dependency graph by hashing the contents of all the declared files in your task definition. This avoids unnecessary work by only running tasks who's dependencies have changed. However, sometimes you want to force a task to run regardless of whether it's dependencies have changed or not. This is where the --force flag comes in. $ spok test - Task \"test\" skipped as none of it's dependencies have changed // Okay fine, let's force it to run $ spok test --force ok github.com/FollowTheProcess/spok/ast (cached) ok github.com/FollowTheProcess/spok/builtins (cached) ok github.com/FollowTheProcess/spok/cache (cached) ? github.com/FollowTheProcess/spok/cli/app [no test files] ? github.com/FollowTheProcess/spok/cli/cmd [no test files] ok github.com/FollowTheProcess/spok/cmd/spok (cached) ok github.com/FollowTheProcess/spok/file (cached) ok github.com/FollowTheProcess/spok/graph (cached) ok github.com/FollowTheProcess/spok/hash (cached) ? github.com/FollowTheProcess/spok/iostream [no test files] ok github.com/FollowTheProcess/spok/lexer (cached) ? github.com/FollowTheProcess/spok/logger [no test files] ok github.com/FollowTheProcess/spok/parser (cached) ok github.com/FollowTheProcess/spok/shell (cached) ok github.com/FollowTheProcess/spok/task (cached) ok github.com/FollowTheProcess/spok/token (cached) \u2705 Task \"test\" completed successfully","title":"--force"},{"location":"cli.html#-json","text":"By default, spok outputs the results of the running tasks in their original format straight to the terminal. This is great for humans, but not so great for machines. If you want to programmatically access the results of a spok run, you can use the --json flag to output the results as JSON, which can then be queried by external programs e.g. jq . For example, let's run a sample task and pipe the output to jq : Here's the spokfile: # Do some things with JSON task echo () { echo \"I succeeded\" } Running spok echo --json will get you: $ spok echo --json | jq [ { \"task\": \"echo\", \"command_results\": [ { \"cmd\": \"echo I succeeded\", \"stdout\": \"I succeeded\\n\", \"stderr\": \"\", \"status\": 0 } ], \"skipped\": false } ] Spok's output JSON is a list of objects, each object representing a task. Each task object contains the following fields: task : The name of the task command_results : A list of objects, each object representing a command run by the task. Each command object contains the following fields: cmd : The command that was run stdout : The stdout of the command stderr : The stderr of the command status : The exit status of the command You can imagine how this could be useful for things like CI/CD pipelines where tasks are more complicated and you may need to query or parse the results of a task or a whole run.","title":"--json"},{"location":"cli.html#-quiet","text":"The --quiet flag does exactly what it says on the tin, shuts Spok up! When using the --quiet flag, Spok will not show any of the task results or any other output at all, simply exit with a zero status code if the run was successful or a non-zero status code if it wasn't. I'd include an example here, but by definition it would be empty! \ud83e\udd13","title":"--quiet"},{"location":"cli.html#-show","text":"The --show flag simply displays all the tasks and their docstrings if present. By default, Spok will do this when it is invoked with no arguments, unless you have declared a task called default , see the user guide for more info on that! To show you what this looks like, consider a simple spokfile: # Run the unit tests task test () { go test ./... } # Format the source code task fmt () { go fmt ./... } # Run the linter task lint () { golangci - lint run -- fix } Running spok with no arguments, or spok --show will get you: $ spok --show Tasks defined in /Users/you/yourproject/spokfile: Name Description fmt Run go fmt on all project files lint Lint the project and auto-fix errors if possible test Run all project tests Tip --show comes in handy when you've reassigned the default task to do something else \ud83e\udde0","title":"--show"},{"location":"cli.html#-spokfile","text":"The --spokfile flag is used to specify the path to the spokfile. By default, Spok will look for a spokfile in the current working directory. Note The path doesn't have to be absolute, if you use a relative path, Spok will assume you meant relative to the current working directory.","title":"--spokfile"},{"location":"cli.html#-vars","text":"The --vars flag tells Spok simply to print all the global variables in the spokfile and exit, this is useful for checking whether the outputs of spok's builtin functions are what you expect. For example: TAG := exec ( \"git describe --tags --abbrev=0\" ) COMMIT := exec ( \"git rev-parse HEAD\" ) Will get you: $ spok --vars Variables defined in /Users/you/yourproject/spokfile: Name Value TAG 0.3.0 COMMIT 3f2a1c2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f","title":"--vars"},{"location":"cli.html#-verbose","text":"If you're ever curious what's going on under the hood, you can use the --verbose flag to get a more detailed output of what Spok is doing during any other CLI operation: $ spok test --verbose 2022-11-27T10:10:26.441Z DEBUG Looking in /Users/tomfleet/Development/spok for spokfile 2022-11-27T10:10:26.442Z DEBUG Found spokfile at /Users/tomfleet/Development/spok/spokfile 2022-11-27T10:10:26.442Z DEBUG Looking for .env file 2022-11-27T10:10:26.442Z DEBUG No .env file found 2022-11-27T10:10:26.442Z DEBUG Parsing spokfile at /Users/tomfleet/Development/spok/spokfile 2022-11-27T10:10:26.459Z DEBUG Running requested tasks: [test] 2022-11-27T10:10:26.760Z DEBUG Building dependency graph for requested tasks: [test] 2022-11-27T10:10:26.760Z DEBUG Calculating topological sort of dependency graph 2022-11-27T10:10:26.761Z DEBUG Task test glob dependency pattern \"**/*.go\" expanded to 34 files 2022-11-27T10:10:26.761Z DEBUG Task test depends on 34 files 2022-11-27T10:10:26.765Z DEBUG Task test current checksum: 670d2ef1c36f6e1 cached checksum: 670d2ef1c36f6e1 - Task \"test\" skipped as none of its dependencies have changed","title":"--verbose"},{"location":"contributing.html","text":"Contributing to spok \u00b6 I've tried to structure spok to make it nice and easy for people to contribute. Here's how to go about doing it! Developing \u00b6 If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to spok: here's how you do it! Step 1: Fork spok \u00b6 The first thing to do is 'fork' spok. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of spok still works! To create a fork, go to the spok repo and click on the fork button! Step 2: Clone your fork \u00b6 Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/spok.git If you use SSH: git clone git@github.com:<your_github_username>/spok.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/spok HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd spok This will take you into the root directory of the project. Now add the original spok repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/spok.git This makes the original version of spok upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower! Step 3: Make your Change \u00b6 Always checkout a new branch before changing anything git switch --create <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! spok aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! spok uses just for automated testing, formatting and linting etc. So when you've made your changes, just run: just check And it will tell you if something's wrong! Step 4: Commit your changes \u00b6 Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name> Step 5: Create a Pull Request \u00b6 Now go to the original spok repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by spok's CI suite and if everything passes and your PR is approved and merged then it will become part of spok! Contributing to Docs \u00b6 Any improvements to the documentation are always appreciated! spok uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Spok uses nox to build and serve the documentation, nox is a python project and can be installed with pipx . # Builds the docs nox -s build # Builds and serves nox -s serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Contribution Guide"},{"location":"contributing.html#contributing-to-spok","text":"I've tried to structure spok to make it nice and easy for people to contribute. Here's how to go about doing it!","title":"Contributing to spok"},{"location":"contributing.html#developing","text":"If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to spok: here's how you do it!","title":"Developing"},{"location":"contributing.html#step-1-fork-spok","text":"The first thing to do is 'fork' spok. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of spok still works! To create a fork, go to the spok repo and click on the fork button!","title":"Step 1: Fork spok"},{"location":"contributing.html#step-2-clone-your-fork","text":"Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/spok.git If you use SSH: git clone git@github.com:<your_github_username>/spok.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/spok HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd spok This will take you into the root directory of the project. Now add the original spok repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/spok.git This makes the original version of spok upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower!","title":"Step 2: Clone your fork"},{"location":"contributing.html#step-3-make-your-change","text":"Always checkout a new branch before changing anything git switch --create <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! spok aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! spok uses just for automated testing, formatting and linting etc. So when you've made your changes, just run: just check And it will tell you if something's wrong!","title":"Step 3: Make your Change"},{"location":"contributing.html#step-4-commit-your-changes","text":"Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name>","title":"Step 4: Commit your changes"},{"location":"contributing.html#step-5-create-a-pull-request","text":"Now go to the original spok repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by spok's CI suite and if everything passes and your PR is approved and merged then it will become part of spok!","title":"Step 5: Create a Pull Request"},{"location":"contributing.html#contributing-to-docs","text":"Any improvements to the documentation are always appreciated! spok uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Spok uses nox to build and serve the documentation, nox is a python project and can be installed with pipx . # Builds the docs nox -s build # Builds and serves nox -s serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Contributing to Docs"},{"location":"quickstart.html","text":"Quickstart \u00b6 Getting started with spok is easy! All you need to do is run: $ spok --init \u2705 Done This will create a spokfile in your current directory that looks like this: # This is a spokfile example VERSION := \"0.3.0\" # Run the unit tests task test ( \"**/*.go\" ) { go test ./... } # Which version am I task version () { echo {{ . VERSION }} } And add the following to your .gitignore : # Ignore the spok cache directory .spok/ So now you're ready to go, if you run spok you'll see the following: $ spok Tasks defined in /Users/you/yourproject/spokfile: Name Description test Run the unit tests version Which version am I If you run spok version you'll see: $ spok version 0.3.0 Next let's take a look at the spokfile syntax and how to use it.","title":"Quickstart"},{"location":"quickstart.html#quickstart","text":"Getting started with spok is easy! All you need to do is run: $ spok --init \u2705 Done This will create a spokfile in your current directory that looks like this: # This is a spokfile example VERSION := \"0.3.0\" # Run the unit tests task test ( \"**/*.go\" ) { go test ./... } # Which version am I task version () { echo {{ . VERSION }} } And add the following to your .gitignore : # Ignore the spok cache directory .spok/ So now you're ready to go, if you run spok you'll see the following: $ spok Tasks defined in /Users/you/yourproject/spokfile: Name Description test Run the unit tests version Which version am I If you run spok version you'll see: $ spok version 0.3.0 Next let's take a look at the spokfile syntax and how to use it.","title":"Quickstart"},{"location":"user_guide.html","text":"User Guide \u00b6 Syntax \u00b6 When spok runs, it parses the syntax in your spokfile, extracts tasks, variables, and dependencies, and then runs the tasks you specify. In this section we'll take a look at the syntax and how to use it Global Variables \u00b6 Let's start simple, Spok lets you define variables in the global scope. These variables can be used in any task. For example: VERSION := \"0.3.0\" # Show the version task version () { echo {{ . VERSION }} } Tip Global variables are also exported as environment variables to the tasks, so if your tasks invoke other scripts that depend on environment variables you can just declare them globally in spok. Builtin Functions \u00b6 Sometimes you need to do more than just run a test, or you need to do something that is not supported by the shell. Spok has a few builtin functions that you can use in your tasks. These functions are: join - Joins a list of path parts with an OS specific path separator and returns the absolute path exec - Executes a shell command and captures the output (stripped of leading/trailing whitespace) in the variable it's assigned to You use them like this: DOCS_SRC := join ( \".\" , \"docs\" , \"src\" ) # => \"/Users/you/project/docs/src\" GIT_COMMIT := exec ( \"git rev-parse HEAD\" ) # => \"a1b2c3d4e5f6\" Note More builtins TBC, spok is still in its early stages \ud83d\ude80 Tasks \u00b6 Tasks are the main point of Spok and are most likely where you'll spend most of your time. Tasks are preceded with the task keyword followed by the task definition. For example, a simple task that runs unit tests might look like: task test () { go test ./... } Warning Just like functions in most programming languages, tasks must have opening and closing parentheses, omitting them is grounds for a syntax error. Now that you have a task defined, you can run it with spok test and your tests will run, how cool is that! \ud83c\udf89 Task Documentation \u00b6 If you want to document your tasks, you can do so by adding a comment above the task definition. For example: # Run all project unit tests task test () { go test ./... } Spok will parse this as the task's docstring and it will be output when the tasks are listed, either by the default action or the --show flag. But we'll get to that later in the CLI section \ud83d\udc4d Tasks that Depend on Files \u00b6 This is fine, and might be enough for you if your test suite is fast and/or the language tooling you're using caches results (like Go!). But what if you have a large test suite and only want to re-run the tests if the source code has changed? Or what if you have a task that depends on another? Luckily, Spok supports both of these types of dependencies! Let's say you're working in a very large python project and the tests take a while to run. You don't want to run the tests if the source code hasn't changed since you last ran them. You can do this by adding a dependency to the test task: task test ( \"**/*.py\" ) { python - m pytest } By including the \"**/*.py\" , Spok will now know that the test task depends on all python files in the project, and that (after the initial run) it should only be re-run if any of those files have changed. So now if you run spok test , your tests will run as before. But try running it again! Spok will notice that none of the python files have changed and you will see: $ spok test - Task \"test\" skipped as none of its dependencies have changed You can do this with as many files or glob patterns as you want, if any of them have changed, the task will be re-run, e.g. this is completely allowed: task lots ( \"**/*.go\" , \"**/*.py\" , \"some/specific/file.txt\" ) { ... } Info When you declare file dependencies like this, behind the scenes Spok will expand the glob patterns to their concrete, absolute filepaths, open and read the contents of each one, and then generate a SHA256 hash of the contents, summing it all up into a final digest and caching this digest against the name of the task. When you run the task again, Spok will do the same procedure, and compare the newly calculated digest against the cached one to determine if the task should be re run. This type of content checking is more accurate than e.g. make which looks at file modification timestamps. A Note on Performance \u00b6 \"But if you open and read the contents of every single file every time you run the task, isn't this really slow?\" In a word... no! Spok is designed to be fast : The expansion of glob patterns happens once, when the spokfile is parsed, and the results are cached in memory for re-use The opening, reading and hashing of file contents happens concurrently across all your cores It's written in Go so it's naturally pretty fast anyway! All this means that, even on very large projects, Spok can perform this check in a few hundred milliseconds \ud83d\ude80 For example on the golang/go repo itself with 8872 .go files (at the time of writing) and the following benchmark task: # Benchmark hashing all go files task test ( \"**/*.go\" ) { echo \"I depend on all go files\" } Spok is able to detect that nothing has changed in any of the 8872 files in just 300ms on my laptop! Don't forget, this also includes the time it takes to: Launch the program itself Read and parse the spokfile Expand the glob pattern \"**/*.go\" and collect the results So hopefully it's plenty fast enough! Tasks that Depend on Other Tasks \u00b6 Not only can you depend on files, you can also depend on other tasks, or a mix of both! If you put the name of another task in the task arguments, Spok will recognise this as a task dependency and will ensure that the declared task will always run before the one you want. For example, let's say you want a Spok task to compile your project, but before that you have to run some sort of code generation, or you want to run the linter or formatter first. You can do this by declaring a dependency in your build task on whatever you want to run before it: # Run the formatter task fmt () { go fmt ./... } # Run the linter task lint ( fmt ) { golangci - lint run } # Compile the project task build ( lint ) { go build ./... } In this example, the build task depends on the lint task, which in-turn depends on the fmt task. So when you run spok build , Spok will construct the dependency graph of the requested tasks, and then run them in the correct order, so you should see something like: $ spok build \u2705 Task \"fmt\" completed successfully \u2705 Task \"lint\" completed successfully \u2705 Task \"build\" completed successfully You can also mix and match tasks depending on files and each other, as in the following example: # Generate the API schema from swagger task generate ( \"api/swagger.yaml\" ) { swagger generate spec - o api / schema . json } # Compile the project task build ( generate , \"**/*.go\" ) { go build ./... } Here we want to generate an API schema from a swagger file, but only if the swagger file has changed. We also want to compile the project which may include or embed this swagger schema, so generate will always run first, and then build will run, but only if any of the go files have changed since the last run. Hopefully you can see how powerful this is! Using a very simple and expressive syntax, you can build up complex dependency graphs of tasks that will only run when they need to, so no time is wasted doing unnecessary work. Note At the moment, spok will not recurse down the dependency graph and so will not look at dependencies of dependencies. For example if you had the following spokfile: # Run the linter task lint ( \"**/*.go\" ) { golangci - lint run } # Run the tests task test ( lint ) { go test ./... } Task test would always run after lint , but it would run even if no go files had changed. To declare that test should also only run if any of the go files have changed, you would need to add the dependency to test as well: # Run the tests task test ( lint , \"**/*.go\" ) { go test ./... } Task Outputs \u00b6 Some tasks generate external artifacts, such as compiled binaries, or generated code. In Spok, you can explicitly declare this by using the output operator -> . For example, here's a task that compiles a Go binary and saves it under the bin directory: # Build the project task build ( \"**/*.go\" ) -> \"bin/myproject\" { go build - o bin / myproject ./... } Declaring an output like this is optional, but it has a pretty cool benefit! $ spok --clean Removed /Users/you/myproject/bin/myproject Yep, Spok can automatically clean up after you! \ud83c\udf89 This is useful if you generate a lot of stuff and want to easily clean up after yourself e.g. if your tasks generate profiles, coverage reports, flamegraphs or other artifacts that you don't want to commit to your repo. You can also declare multiple outputs by separating them with commas inside parentheses, like so: # Output lots of stuff task build ( \"**/*.go\" ) -> ( \"bin/myproject\" , \"bin/myproject2\" ) { go build - o bin / myproject ./... go build - o bin / myproject2 ./... } Or even glob patterns of outputs! For example if your task is to convert markdown to html docs pages, you could do something like: # Build the docs html from source task docs ( \"docs/src/*.md\" ) -> \"docs/build/*.html\" { mkdocs build } Just like with file dependencies, these globs will be expanded to their concrete filepaths and each one would be deleted by spok --clean Default Tasks \u00b6 We saw earlier that if you run spok without any arguments, it will show the list of all tasks in your spokfile. But what if you wanted to do something else instead? Well... you can! All you need to do is declare a task called default and then when you run spok without any arguments, it will run that task instead: # Do this by default task default () { echo \"Hello from the default task\" } $ spok Hello from the default task Custom Clean Operation \u00b6 Spok automatically keeps track of task outputs and will delete them when you run spok --clean . But like declaring default tasks , you can also declare a custom clean operation by writing a task called clean : # Do custom cleany things task clean () { echo \"Cleaning up...\" } $ spok --clean Cleaning up... Dotenv Support \u00b6 If Spok finds a file called .env in the same directory as your spokfile, it will automatically load it and make the variables available to all it's tasks. For example, if you had a .env file like this: VALUE=\"hello from .env\" And a spokfile like this: # Use a variable from .env task dotenv () { echo $ VALUE } When you run spok dotenv , you'll get: $ spok dotenv hello from .env That's really it! Let's move on and talk about what you can do with the CLI","title":"User Guide"},{"location":"user_guide.html#user-guide","text":"","title":"User Guide"},{"location":"user_guide.html#syntax","text":"When spok runs, it parses the syntax in your spokfile, extracts tasks, variables, and dependencies, and then runs the tasks you specify. In this section we'll take a look at the syntax and how to use it","title":"Syntax"},{"location":"user_guide.html#global-variables","text":"Let's start simple, Spok lets you define variables in the global scope. These variables can be used in any task. For example: VERSION := \"0.3.0\" # Show the version task version () { echo {{ . VERSION }} } Tip Global variables are also exported as environment variables to the tasks, so if your tasks invoke other scripts that depend on environment variables you can just declare them globally in spok.","title":"Global Variables"},{"location":"user_guide.html#builtin-functions","text":"Sometimes you need to do more than just run a test, or you need to do something that is not supported by the shell. Spok has a few builtin functions that you can use in your tasks. These functions are: join - Joins a list of path parts with an OS specific path separator and returns the absolute path exec - Executes a shell command and captures the output (stripped of leading/trailing whitespace) in the variable it's assigned to You use them like this: DOCS_SRC := join ( \".\" , \"docs\" , \"src\" ) # => \"/Users/you/project/docs/src\" GIT_COMMIT := exec ( \"git rev-parse HEAD\" ) # => \"a1b2c3d4e5f6\" Note More builtins TBC, spok is still in its early stages \ud83d\ude80","title":"Builtin Functions"},{"location":"user_guide.html#tasks","text":"Tasks are the main point of Spok and are most likely where you'll spend most of your time. Tasks are preceded with the task keyword followed by the task definition. For example, a simple task that runs unit tests might look like: task test () { go test ./... } Warning Just like functions in most programming languages, tasks must have opening and closing parentheses, omitting them is grounds for a syntax error. Now that you have a task defined, you can run it with spok test and your tests will run, how cool is that! \ud83c\udf89","title":"Tasks"},{"location":"user_guide.html#task-documentation","text":"If you want to document your tasks, you can do so by adding a comment above the task definition. For example: # Run all project unit tests task test () { go test ./... } Spok will parse this as the task's docstring and it will be output when the tasks are listed, either by the default action or the --show flag. But we'll get to that later in the CLI section \ud83d\udc4d","title":"Task Documentation"},{"location":"user_guide.html#tasks-that-depend-on-files","text":"This is fine, and might be enough for you if your test suite is fast and/or the language tooling you're using caches results (like Go!). But what if you have a large test suite and only want to re-run the tests if the source code has changed? Or what if you have a task that depends on another? Luckily, Spok supports both of these types of dependencies! Let's say you're working in a very large python project and the tests take a while to run. You don't want to run the tests if the source code hasn't changed since you last ran them. You can do this by adding a dependency to the test task: task test ( \"**/*.py\" ) { python - m pytest } By including the \"**/*.py\" , Spok will now know that the test task depends on all python files in the project, and that (after the initial run) it should only be re-run if any of those files have changed. So now if you run spok test , your tests will run as before. But try running it again! Spok will notice that none of the python files have changed and you will see: $ spok test - Task \"test\" skipped as none of its dependencies have changed You can do this with as many files or glob patterns as you want, if any of them have changed, the task will be re-run, e.g. this is completely allowed: task lots ( \"**/*.go\" , \"**/*.py\" , \"some/specific/file.txt\" ) { ... } Info When you declare file dependencies like this, behind the scenes Spok will expand the glob patterns to their concrete, absolute filepaths, open and read the contents of each one, and then generate a SHA256 hash of the contents, summing it all up into a final digest and caching this digest against the name of the task. When you run the task again, Spok will do the same procedure, and compare the newly calculated digest against the cached one to determine if the task should be re run. This type of content checking is more accurate than e.g. make which looks at file modification timestamps.","title":"Tasks that Depend on Files"},{"location":"user_guide.html#a-note-on-performance","text":"\"But if you open and read the contents of every single file every time you run the task, isn't this really slow?\" In a word... no! Spok is designed to be fast : The expansion of glob patterns happens once, when the spokfile is parsed, and the results are cached in memory for re-use The opening, reading and hashing of file contents happens concurrently across all your cores It's written in Go so it's naturally pretty fast anyway! All this means that, even on very large projects, Spok can perform this check in a few hundred milliseconds \ud83d\ude80 For example on the golang/go repo itself with 8872 .go files (at the time of writing) and the following benchmark task: # Benchmark hashing all go files task test ( \"**/*.go\" ) { echo \"I depend on all go files\" } Spok is able to detect that nothing has changed in any of the 8872 files in just 300ms on my laptop! Don't forget, this also includes the time it takes to: Launch the program itself Read and parse the spokfile Expand the glob pattern \"**/*.go\" and collect the results So hopefully it's plenty fast enough!","title":"A Note on Performance"},{"location":"user_guide.html#tasks-that-depend-on-other-tasks","text":"Not only can you depend on files, you can also depend on other tasks, or a mix of both! If you put the name of another task in the task arguments, Spok will recognise this as a task dependency and will ensure that the declared task will always run before the one you want. For example, let's say you want a Spok task to compile your project, but before that you have to run some sort of code generation, or you want to run the linter or formatter first. You can do this by declaring a dependency in your build task on whatever you want to run before it: # Run the formatter task fmt () { go fmt ./... } # Run the linter task lint ( fmt ) { golangci - lint run } # Compile the project task build ( lint ) { go build ./... } In this example, the build task depends on the lint task, which in-turn depends on the fmt task. So when you run spok build , Spok will construct the dependency graph of the requested tasks, and then run them in the correct order, so you should see something like: $ spok build \u2705 Task \"fmt\" completed successfully \u2705 Task \"lint\" completed successfully \u2705 Task \"build\" completed successfully You can also mix and match tasks depending on files and each other, as in the following example: # Generate the API schema from swagger task generate ( \"api/swagger.yaml\" ) { swagger generate spec - o api / schema . json } # Compile the project task build ( generate , \"**/*.go\" ) { go build ./... } Here we want to generate an API schema from a swagger file, but only if the swagger file has changed. We also want to compile the project which may include or embed this swagger schema, so generate will always run first, and then build will run, but only if any of the go files have changed since the last run. Hopefully you can see how powerful this is! Using a very simple and expressive syntax, you can build up complex dependency graphs of tasks that will only run when they need to, so no time is wasted doing unnecessary work. Note At the moment, spok will not recurse down the dependency graph and so will not look at dependencies of dependencies. For example if you had the following spokfile: # Run the linter task lint ( \"**/*.go\" ) { golangci - lint run } # Run the tests task test ( lint ) { go test ./... } Task test would always run after lint , but it would run even if no go files had changed. To declare that test should also only run if any of the go files have changed, you would need to add the dependency to test as well: # Run the tests task test ( lint , \"**/*.go\" ) { go test ./... }","title":"Tasks that Depend on Other Tasks"},{"location":"user_guide.html#task-outputs","text":"Some tasks generate external artifacts, such as compiled binaries, or generated code. In Spok, you can explicitly declare this by using the output operator -> . For example, here's a task that compiles a Go binary and saves it under the bin directory: # Build the project task build ( \"**/*.go\" ) -> \"bin/myproject\" { go build - o bin / myproject ./... } Declaring an output like this is optional, but it has a pretty cool benefit! $ spok --clean Removed /Users/you/myproject/bin/myproject Yep, Spok can automatically clean up after you! \ud83c\udf89 This is useful if you generate a lot of stuff and want to easily clean up after yourself e.g. if your tasks generate profiles, coverage reports, flamegraphs or other artifacts that you don't want to commit to your repo. You can also declare multiple outputs by separating them with commas inside parentheses, like so: # Output lots of stuff task build ( \"**/*.go\" ) -> ( \"bin/myproject\" , \"bin/myproject2\" ) { go build - o bin / myproject ./... go build - o bin / myproject2 ./... } Or even glob patterns of outputs! For example if your task is to convert markdown to html docs pages, you could do something like: # Build the docs html from source task docs ( \"docs/src/*.md\" ) -> \"docs/build/*.html\" { mkdocs build } Just like with file dependencies, these globs will be expanded to their concrete filepaths and each one would be deleted by spok --clean","title":"Task Outputs"},{"location":"user_guide.html#default-tasks","text":"We saw earlier that if you run spok without any arguments, it will show the list of all tasks in your spokfile. But what if you wanted to do something else instead? Well... you can! All you need to do is declare a task called default and then when you run spok without any arguments, it will run that task instead: # Do this by default task default () { echo \"Hello from the default task\" } $ spok Hello from the default task","title":"Default Tasks"},{"location":"user_guide.html#custom-clean-operation","text":"Spok automatically keeps track of task outputs and will delete them when you run spok --clean . But like declaring default tasks , you can also declare a custom clean operation by writing a task called clean : # Do custom cleany things task clean () { echo \"Cleaning up...\" } $ spok --clean Cleaning up...","title":"Custom Clean Operation"},{"location":"user_guide.html#dotenv-support","text":"If Spok finds a file called .env in the same directory as your spokfile, it will automatically load it and make the variables available to all it's tasks. For example, if you had a .env file like this: VALUE=\"hello from .env\" And a spokfile like this: # Use a variable from .env task dotenv () { echo $ VALUE } When you run spok dotenv , you'll get: $ spok dotenv hello from .env That's really it! Let's move on and talk about what you can do with the CLI","title":"Dotenv Support"}]}